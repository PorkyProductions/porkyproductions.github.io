{"version":3,"file":"concurrent.6826359d.js","sources":["../../node_modules/svelte-typewriter/helpers/getLongestTextElement.js","../../node_modules/svelte-typewriter/helpers/onAnimationEnd.js","../../node_modules/svelte-typewriter/modes/concurrent.js"],"sourcesContent":["/** @type {import(types').DescendingSortFunction} */\nconst descendingSortFunction = (firstElement, secondElement) =>\n\tsecondElement.text.length - firstElement.text.length\n\n/** @type {import(types').GetLongestTextElement} */\nconst getLongestTextElement = elements => {\n\tconst descendingTextLengthOrder = elements.sort(descendingSortFunction)\n\tconst longestTextElement = descendingTextLengthOrder[0].currentNode\n\treturn longestTextElement\n}\n\nexport { getLongestTextElement }\n","/** @type {import(types').OnAnimationEnd} */\nconst onAnimationEnd = (element, callback) => {\n\tconst observer = new MutationObserver(mutations => {\n\t\tmutations.forEach(mutation => {\n\t\t\tconst elementAttributeChanged = mutation.type === 'attributes'\n\t\t\tconst elementFinishedTyping = mutation.target.classList.contains('finished-typing')\n\t\t\tif (elementAttributeChanged && elementFinishedTyping) callback()\n\t\t})\n\t})\n\n\tobserver.observe(element, {\n\t\tattributes: true,\n\t\tchildList: true,\n\t\tsubtree: true\n\t})\n}\n\nexport { onAnimationEnd }\n","import { getLongestTextElement } from '../helpers/getLongestTextElement'\nimport { writeEffect } from '../helpers/writeEffect'\nimport { onAnimationEnd } from '../helpers/onAnimationEnd'\nimport { animationSetup } from '../helpers/animationSetup'\n\n// the name \"default\" cannot be used due to being a js keyword\nconst concurrent = (node, props) => {\n\tconst { options, elements } = animationSetup(node, props)\n\n\tconst lastElementToFinish = getLongestTextElement(elements)\n\tonAnimationEnd(lastElementToFinish, () => options.dispatch('done'))\n\n\tfor (const element of elements) {\n\t\t// \"then\" is required here to prevent blocking execution, thus keeping\n\t\t// the animation asynchronous\n\t\twriteEffect(element, options).then(() => {\n\t\t\tif (options.keepCursorOnFinish) {\n\t\t\t\tconst isNotLongestElement = element.currentNode !== lastElementToFinish\n\t\t\t\tisNotLongestElement &&\n\t\t\t\t\telement.currentNode.classList.replace('typing', 'finished-typing')\n\t\t\t} else {\n\t\t\t\telement.currentNode.classList.replace('typing', 'finished-typing')\n\t\t\t}\n\n\t\t\tconst cursorHasTimeout = typeof options.keepCursorOnFinish === 'number'\n\t\t\tcursorHasTimeout &&\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\telement.currentNode.classList.replace('typing', 'finished-typing')\n\t\t\t\t}, options.keepCursorOnFinish)\n\t\t})\n\t}\n}\n\nexport default concurrent\n"],"names":["descendingSortFunction","firstElement","secondElement","getLongestTextElement","elements","onAnimationEnd","element","callback","mutations","mutation","elementAttributeChanged","elementFinishedTyping","concurrent","node","props","options","animationSetup","lastElementToFinish","writeEffect"],"mappings":"kIACA,MAAMA,EAAyB,CAACC,EAAcC,IAC7CA,EAAc,KAAK,OAASD,EAAa,KAAK,OAGzCE,EAAwBC,GACKA,EAAS,KAAKJ,CAAsB,EACjB,GAAG,YCNnDK,EAAiB,CAACC,EAASC,IAAa,CAC5B,IAAI,iBAAiBC,GAAa,CAClDA,EAAU,QAAQC,GAAY,CAC7B,MAAMC,EAA0BD,EAAS,OAAS,aAC5CE,EAAwBF,EAAS,OAAO,UAAU,SAAS,iBAAiB,EAC9EC,GAA2BC,GAAuBJ,EAAU,CACnE,CAAG,CACH,CAAE,EAEQ,QAAQD,EAAS,CACzB,WAAY,GACZ,UAAW,GACX,QAAS,EACX,CAAE,CACF,ECTMM,EAAa,CAACC,EAAMC,IAAU,CACnC,KAAM,CAAE,QAAAC,EAAS,SAAAX,CAAQ,EAAKY,EAAeH,EAAMC,CAAK,EAElDG,EAAsBd,EAAsBC,CAAQ,EAC1DC,EAAeY,EAAqB,IAAMF,EAAQ,SAAS,MAAM,CAAC,EAElE,UAAWT,KAAWF,EAGrBc,EAAYZ,EAASS,CAAO,EAAE,KAAK,IAAM,CACpCA,EAAQ,mBACiBT,EAAQ,cAAgBW,GAEnDX,EAAQ,YAAY,UAAU,QAAQ,SAAU,iBAAiB,EAElEA,EAAQ,YAAY,UAAU,QAAQ,SAAU,iBAAiB,EAGzC,OAAOS,EAAQ,oBAAuB,UAE9D,WAAW,IAAM,CAChBT,EAAQ,YAAY,UAAU,QAAQ,SAAU,iBAAiB,CACtE,EAAOS,EAAQ,kBAAkB,CACjC,CAAG,CAEH"}